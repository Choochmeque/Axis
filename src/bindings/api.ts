/* eslint-disable */
// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openRepository(path: string) : Promise<Repository> {
    return await TAURI_INVOKE("open_repository", { path });
},
async initRepository(path: string, bare: boolean) : Promise<Repository> {
    return await TAURI_INVOKE("init_repository", { path, bare });
},
async cloneRepository(url: string, path: string) : Promise<Repository> {
    return await TAURI_INVOKE("clone_repository", { url, path });
},
async closeRepository() : Promise<null> {
    return await TAURI_INVOKE("close_repository");
},
async switchActiveRepository(path: string) : Promise<Repository> {
    return await TAURI_INVOKE("switch_active_repository", { path });
},
async closeRepositoryPath(path: string) : Promise<null> {
    return await TAURI_INVOKE("close_repository_path", { path });
},
async getRepositoryInfo() : Promise<Repository> {
    return await TAURI_INVOKE("get_repository_info");
},
async getRepositoryStatus() : Promise<RepositoryStatus> {
    return await TAURI_INVOKE("get_repository_status");
},
async getCommitHistory(options: LogOptions) : Promise<Commit[]> {
    return await TAURI_INVOKE("get_commit_history", { options });
},
async getBranches(filter: BranchFilter) : Promise<Branch[]> {
    return await TAURI_INVOKE("get_branches", { filter });
},
async getCommit(oid: string) : Promise<Commit> {
    return await TAURI_INVOKE("get_commit", { oid });
},
async getRecentRepositories() : Promise<RecentRepository[]> {
    return await TAURI_INVOKE("get_recent_repositories");
},
async removeRecentRepository(path: string) : Promise<null> {
    return await TAURI_INVOKE("remove_recent_repository", { path });
},
async showInFolder(path: string) : Promise<null> {
    return await TAURI_INVOKE("show_in_folder", { path });
},
async openUrl(url: string) : Promise<null> {
    return await TAURI_INVOKE("open_url", { url });
},
async openTerminal(path: string) : Promise<null> {
    return await TAURI_INVOKE("open_terminal", { path });
},
async cancelOperation(operationId: string) : Promise<boolean> {
    return await TAURI_INVOKE("cancel_operation", { operationId });
},
async stageFile(path: string) : Promise<null> {
    return await TAURI_INVOKE("stage_file", { path });
},
async stageFiles(paths: string[]) : Promise<null> {
    return await TAURI_INVOKE("stage_files", { paths });
},
async stageAll() : Promise<null> {
    return await TAURI_INVOKE("stage_all");
},
async unstageFile(path: string) : Promise<null> {
    return await TAURI_INVOKE("unstage_file", { path });
},
async unstageFiles(paths: string[]) : Promise<null> {
    return await TAURI_INVOKE("unstage_files", { paths });
},
async unstageAll() : Promise<null> {
    return await TAURI_INVOKE("unstage_all");
},
async discardFile(path: string) : Promise<null> {
    return await TAURI_INVOKE("discard_file", { path });
},
async discardUnstaged() : Promise<null> {
    return await TAURI_INVOKE("discard_unstaged");
},
async createCommit(message: string, authorName: string | null, authorEmail: string | null, sign: boolean | null, bypassHooks: boolean | null) : Promise<string> {
    return await TAURI_INVOKE("create_commit", { message, authorName, authorEmail, sign, bypassHooks });
},
async amendCommit(message: string | null, bypassHooks: boolean | null) : Promise<string> {
    return await TAURI_INVOKE("amend_commit", { message, bypassHooks });
},
async getUserSignature() : Promise<[string, string]> {
    return await TAURI_INVOKE("get_user_signature");
},
async stageHunk(patch: string) : Promise<null> {
    return await TAURI_INVOKE("stage_hunk", { patch });
},
async unstageHunk(patch: string) : Promise<null> {
    return await TAURI_INVOKE("unstage_hunk", { patch });
},
async discardHunk(patch: string) : Promise<null> {
    return await TAURI_INVOKE("discard_hunk", { patch });
},
async deleteFile(path: string) : Promise<null> {
    return await TAURI_INVOKE("delete_file", { path });
},
/**
 * Get diff based on the specified target
 */
async getDiff(target: DiffTarget, options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff", { target, options });
},
/**
 * Get diff for unstaged changes (working directory vs index)
 */
async getDiffWorkdir(options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff_workdir", { options });
},
/**
 * Get diff for staged changes (index vs HEAD)
 */
async getDiffStaged(options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff_staged", { options });
},
/**
 * Get diff for all uncommitted changes (working directory vs HEAD)
 */
async getDiffHead(options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff_head", { options });
},
/**
 * Get diff for a specific commit (commit vs its parent)
 */
async getDiffCommit(oid: string, options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff_commit", { oid, options });
},
/**
 * Get diff between two commits
 */
async getDiffCommits(fromOid: string, toOid: string, options: DiffOptions | null) : Promise<FileDiff[]> {
    return await TAURI_INVOKE("get_diff_commits", { fromOid, toOid, options });
},
/**
 * Get diff for a single file (staged or unstaged)
 */
async getFileDiff(path: string, staged: boolean, options: DiffOptions | null) : Promise<FileDiff | null> {
    return await TAURI_INVOKE("get_file_diff", { path, staged, options });
},
/**
 * Create a new branch
 */
async createBranch(name: string, options: CreateBranchOptions) : Promise<Branch> {
    return await TAURI_INVOKE("create_branch", { name, options });
},
/**
 * Delete a branch
 */
async deleteBranch(name: string, force: boolean | null) : Promise<null> {
    return await TAURI_INVOKE("delete_branch", { name, force });
},
/**
 * Delete a remote branch
 */
async deleteRemoteBranch(remoteName: string, branchName: string, force: boolean | null) : Promise<null> {
    return await TAURI_INVOKE("delete_remote_branch", { remoteName, branchName, force });
},
/**
 * Rename a branch
 */
async renameBranch(oldName: string, newName: string, force: boolean | null) : Promise<Branch> {
    return await TAURI_INVOKE("rename_branch", { oldName, newName, force });
},
/**
 * Checkout a branch
 */
async checkoutBranch(name: string, options: CheckoutOptions) : Promise<null> {
    return await TAURI_INVOKE("checkout_branch", { name, options });
},
/**
 * Checkout a remote branch locally
 */
async checkoutRemoteBranch(remoteName: string, branchName: string, localName: string | null, force: boolean) : Promise<null> {
    return await TAURI_INVOKE("checkout_remote_branch", { remoteName, branchName, localName, force });
},
/**
 * Get branch details
 */
async getBranch(name: string, branchType: BranchType) : Promise<Branch> {
    return await TAURI_INVOKE("get_branch", { name, branchType });
},
/**
 * Set the upstream branch for a local branch
 */
async setBranchUpstream(branchName: string, upstream: string | null) : Promise<null> {
    return await TAURI_INVOKE("set_branch_upstream", { branchName, upstream });
},
/**
 * Compare two branches to find commits ahead/behind and file differences
 */
async compareBranches(baseRef: string, compareRef: string) : Promise<BranchCompareResult> {
    return await TAURI_INVOKE("compare_branches", { baseRef, compareRef });
},
async listRemotes() : Promise<Remote[]> {
    return await TAURI_INVOKE("list_remotes");
},
async getRemote(name: string) : Promise<Remote> {
    return await TAURI_INVOKE("get_remote", { name });
},
async addRemote(name: string, url: string) : Promise<Remote> {
    return await TAURI_INVOKE("add_remote", { name, url });
},
async removeRemote(name: string) : Promise<null> {
    return await TAURI_INVOKE("remove_remote", { name });
},
async renameRemote(oldName: string, newName: string) : Promise<string[]> {
    return await TAURI_INVOKE("rename_remote", { oldName, newName });
},
async setRemoteUrl(name: string, url: string) : Promise<null> {
    return await TAURI_INVOKE("set_remote_url", { name, url });
},
async setRemotePushUrl(name: string, url: string) : Promise<null> {
    return await TAURI_INVOKE("set_remote_push_url", { name, url });
},
async fetchRemote(remoteName: string, options: FetchOptions) : Promise<FetchResult> {
    return await TAURI_INVOKE("fetch_remote", { remoteName, options });
},
async pushRemote(remoteName: string, refspecs: string[], options: PushOptions, bypassHooks: boolean | null) : Promise<PushResult> {
    return await TAURI_INVOKE("push_remote", { remoteName, refspecs, options, bypassHooks });
},
async pushCurrentBranch(remoteName: string, options: PushOptions, bypassHooks: boolean | null) : Promise<PushResult> {
    return await TAURI_INVOKE("push_current_branch", { remoteName, options, bypassHooks });
},
async pullRemote(remoteName: string, branchName: string, options: PullOptions) : Promise<null> {
    return await TAURI_INVOKE("pull_remote", { remoteName, branchName, options });
},
async fetchAll() : Promise<FetchResult[]> {
    return await TAURI_INVOKE("fetch_all");
},
/**
 * Build commit graph with lane assignments for visualization
 */
async buildGraph(options: GraphOptions | null) : Promise<GraphResult> {
    return await TAURI_INVOKE("build_graph", { options });
},
/**
 * Search commits by message, author, or hash
 */
async searchCommits(options: SearchOptions) : Promise<SearchResult> {
    return await TAURI_INVOKE("search_commits", { options });
},
/**
 * Get blame information for a file
 */
async blameFile(path: string, commitOid: string | null) : Promise<BlameResult> {
    return await TAURI_INVOKE("blame_file", { path, commitOid });
},
/**
 * Get total commit count for pagination
 */
async getCommitCount(fromRef: string | null) : Promise<number> {
    return await TAURI_INVOKE("get_commit_count", { fromRef });
},
/**
 * Get commit history for specific files
 */
async getFileHistory(options: FileLogOptions) : Promise<FileLogResult> {
    return await TAURI_INVOKE("get_file_history", { options });
},
/**
 * Get diff for a specific file in a specific commit
 */
async getFileDiffInCommit(commitOid: string, path: string, options: DiffOptions | null) : Promise<FileDiff | null> {
    return await TAURI_INVOKE("get_file_diff_in_commit", { commitOid, path, options });
},
/**
 * Merge a branch into the current branch
 */
async mergeBranch(options: MergeOptions) : Promise<MergeResult> {
    return await TAURI_INVOKE("merge_branch", { options });
},
/**
 * Abort an in-progress merge
 */
async mergeAbort() : Promise<null> {
    return await TAURI_INVOKE("merge_abort");
},
/**
 * Continue a merge after resolving conflicts
 */
async mergeContinue() : Promise<MergeResult> {
    return await TAURI_INVOKE("merge_continue");
},
/**
 * Start a rebase onto a target branch
 */
async rebaseBranch(options: RebaseOptions, bypassHooks: boolean | null) : Promise<RebaseResult> {
    return await TAURI_INVOKE("rebase_branch", { options, bypassHooks });
},
/**
 * Abort an in-progress rebase
 */
async rebaseAbort() : Promise<null> {
    return await TAURI_INVOKE("rebase_abort");
},
/**
 * Continue a rebase after resolving conflicts
 */
async rebaseContinue() : Promise<RebaseResult> {
    return await TAURI_INVOKE("rebase_continue");
},
/**
 * Skip the current commit during rebase
 */
async rebaseSkip() : Promise<RebaseResult> {
    return await TAURI_INVOKE("rebase_skip");
},
/**
 * Get preview information for a rebase operation
 */
async getRebasePreview(onto: string) : Promise<RebasePreview> {
    return await TAURI_INVOKE("get_rebase_preview", { onto });
},
/**
 * Get interactive rebase preview with entries prepared for editing
 */
async getInteractiveRebasePreview(onto: string) : Promise<InteractiveRebasePreview> {
    return await TAURI_INVOKE("get_interactive_rebase_preview", { onto });
},
/**
 * Start an interactive rebase with pre-configured actions
 */
async interactiveRebase(options: InteractiveRebaseOptions, bypassHooks: boolean | null) : Promise<RebaseResult> {
    return await TAURI_INVOKE("interactive_rebase", { options, bypassHooks });
},
/**
 * Cherry-pick commits
 */
async cherryPick(options: CherryPickOptions) : Promise<CherryPickResult> {
    return await TAURI_INVOKE("cherry_pick", { options });
},
/**
 * Abort an in-progress cherry-pick
 */
async cherryPickAbort() : Promise<null> {
    return await TAURI_INVOKE("cherry_pick_abort");
},
/**
 * Continue cherry-pick after resolving conflicts
 */
async cherryPickContinue() : Promise<CherryPickResult> {
    return await TAURI_INVOKE("cherry_pick_continue");
},
/**
 * Skip the current commit during cherry-pick
 */
async cherryPickSkip() : Promise<CherryPickResult> {
    return await TAURI_INVOKE("cherry_pick_skip");
},
/**
 * Revert commits
 */
async revertCommits(options: RevertOptions) : Promise<RevertResult> {
    return await TAURI_INVOKE("revert_commits", { options });
},
/**
 * Abort an in-progress revert
 */
async revertAbort() : Promise<null> {
    return await TAURI_INVOKE("revert_abort");
},
/**
 * Continue revert after resolving conflicts
 */
async revertContinue() : Promise<RevertResult> {
    return await TAURI_INVOKE("revert_continue");
},
/**
 * Get list of conflicted files
 */
async getConflictedFiles() : Promise<ConflictedFile[]> {
    return await TAURI_INVOKE("get_conflicted_files");
},
/**
 * Get three-way content for a conflicted file
 */
async getConflictContent(path: string) : Promise<ConflictContent> {
    return await TAURI_INVOKE("get_conflict_content", { path });
},
/**
 * Resolve a conflict by choosing a version
 */
async resolveConflict(path: string, resolution: ConflictResolution, customContent: string | null) : Promise<null> {
    return await TAURI_INVOKE("resolve_conflict", { path, resolution, customContent });
},
/**
 * Mark a file as resolved
 */
async markConflictResolved(path: string) : Promise<null> {
    return await TAURI_INVOKE("mark_conflict_resolved", { path });
},
/**
 * Get the current operation in progress
 */
async getOperationState() : Promise<OperationState> {
    return await TAURI_INVOKE("get_operation_state");
},
/**
 * Start a bisect session
 */
async bisectStart(options: BisectStartOptions) : Promise<BisectResult> {
    return await TAURI_INVOKE("bisect_start", { options });
},
/**
 * Mark a commit during bisect
 */
async bisectMark(mark: BisectMarkType, commit: string | null) : Promise<BisectResult> {
    return await TAURI_INVOKE("bisect_mark", { mark, commit });
},
/**
 * Reset/end the bisect session
 */
async bisectReset(commit: string | null) : Promise<BisectResult> {
    return await TAURI_INVOKE("bisect_reset", { commit });
},
/**
 * Get current bisect state
 */
async bisectState() : Promise<BisectState> {
    return await TAURI_INVOKE("bisect_state");
},
/**
 * Get bisect log
 */
async bisectLog() : Promise<string> {
    return await TAURI_INVOKE("bisect_log");
},
/**
 * Reset the repository to a specific commit
 */
async resetToCommit(options: ResetOptions) : Promise<null> {
    return await TAURI_INVOKE("reset_to_commit", { options });
},
/**
 * List all stash entries
 */
async stashList() : Promise<StashEntry[]> {
    return await TAURI_INVOKE("stash_list");
},
/**
 * Create a new stash
 */
async stashSave(options: StashSaveOptions) : Promise<StashResult> {
    return await TAURI_INVOKE("stash_save", { options });
},
/**
 * Apply a stash (keep it in the stash list)
 */
async stashApply(options: StashApplyOptions) : Promise<StashResult> {
    return await TAURI_INVOKE("stash_apply", { options });
},
/**
 * Pop a stash (apply and remove from stash list)
 */
async stashPop(options: StashApplyOptions) : Promise<StashResult> {
    return await TAURI_INVOKE("stash_pop", { options });
},
/**
 * Drop a stash entry
 */
async stashDrop(index: number | null) : Promise<StashResult> {
    return await TAURI_INVOKE("stash_drop", { index });
},
/**
 * Clear all stashes
 */
async stashClear() : Promise<StashResult> {
    return await TAURI_INVOKE("stash_clear");
},
/**
 * Show the diff of a stash
 */
async stashShow(index: number | null, statOnly: boolean) : Promise<string> {
    return await TAURI_INVOKE("stash_show", { index, statOnly });
},
/**
 * Create a branch from a stash
 */
async stashBranch(branchName: string, index: number | null) : Promise<StashResult> {
    return await TAURI_INVOKE("stash_branch", { branchName, index });
},
/**
 * List reflog entries for a reference
 */
async reflogList(options: ReflogOptions) : Promise<ReflogEntry[]> {
    return await TAURI_INVOKE("reflog_list", { options });
},
/**
 * Get list of available reflogs (references that have reflog)
 */
async reflogRefs() : Promise<string[]> {
    return await TAURI_INVOKE("reflog_refs");
},
/**
 * Get total count of reflog entries for a reference
 */
async reflogCount(refname: string) : Promise<number> {
    return await TAURI_INVOKE("reflog_count", { refname });
},
/**
 * Checkout to a reflog entry (creates detached HEAD)
 */
async reflogCheckout(reflogRef: string) : Promise<null> {
    return await TAURI_INVOKE("reflog_checkout", { reflogRef });
},
/**
 * List all tags
 */
async tagList() : Promise<Tag[]> {
    return await TAURI_INVOKE("tag_list");
},
/**
 * Create a new tag
 */
async tagCreate(name: string, options: CreateTagOptions) : Promise<TagResult> {
    return await TAURI_INVOKE("tag_create", { name, options });
},
/**
 * Delete a local tag
 */
async tagDelete(name: string) : Promise<TagResult> {
    return await TAURI_INVOKE("tag_delete", { name });
},
/**
 * Push a tag to a remote
 */
async tagPush(name: string, remote: string) : Promise<TagResult> {
    return await TAURI_INVOKE("tag_push", { name, remote });
},
/**
 * Push all tags to a remote
 */
async tagPushAll(remote: string) : Promise<TagResult> {
    return await TAURI_INVOKE("tag_push_all", { remote });
},
/**
 * Delete a remote tag
 */
async tagDeleteRemote(name: string, remote: string) : Promise<TagResult> {
    return await TAURI_INVOKE("tag_delete_remote", { name, remote });
},
/**
 * List all submodules
 */
async submoduleList() : Promise<Submodule[]> {
    return await TAURI_INVOKE("submodule_list");
},
/**
 * Add a new submodule
 */
async submoduleAdd(options: AddSubmoduleOptions) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_add", { options });
},
/**
 * Initialize submodules
 */
async submoduleInit(paths: string[]) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_init", { paths });
},
/**
 * Update submodules
 */
async submoduleUpdate(options: UpdateSubmoduleOptions) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_update", { options });
},
/**
 * Sync submodule URLs from .gitmodules
 */
async submoduleSync(options: SyncSubmoduleOptions) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_sync", { options });
},
/**
 * Deinitialize submodules
 */
async submoduleDeinit(paths: string[], force: boolean) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_deinit", { paths, force });
},
/**
 * Remove a submodule completely
 */
async submoduleRemove(path: string) : Promise<SubmoduleResult> {
    return await TAURI_INVOKE("submodule_remove", { path });
},
/**
 * Get summary of submodule changes
 */
async submoduleSummary() : Promise<string> {
    return await TAURI_INVOKE("submodule_summary");
},
/**
 * List all worktrees
 */
async worktreeList() : Promise<Worktree[]> {
    return await TAURI_INVOKE("worktree_list");
},
/**
 * Add a new worktree
 */
async worktreeAdd(options: AddWorktreeOptions) : Promise<WorktreeResult> {
    return await TAURI_INVOKE("worktree_add", { options });
},
/**
 * Remove a worktree
 */
async worktreeRemove(options: RemoveWorktreeOptions) : Promise<WorktreeResult> {
    return await TAURI_INVOKE("worktree_remove", { options });
},
/**
 * Lock a worktree
 */
async worktreeLock(path: string, reason: string | null) : Promise<WorktreeResult> {
    return await TAURI_INVOKE("worktree_lock", { path, reason });
},
/**
 * Unlock a worktree
 */
async worktreeUnlock(path: string) : Promise<WorktreeResult> {
    return await TAURI_INVOKE("worktree_unlock", { path });
},
/**
 * Prune stale worktree references
 */
async worktreePrune(dryRun: boolean) : Promise<WorktreeResult> {
    return await TAURI_INVOKE("worktree_prune", { dryRun });
},
/**
 * Check if git-flow is initialized
 */
async gitflowIsInitialized() : Promise<boolean> {
    return await TAURI_INVOKE("gitflow_is_initialized");
},
/**
 * Get git-flow configuration
 */
async gitflowConfig() : Promise<GitFlowConfig | null> {
    return await TAURI_INVOKE("gitflow_config");
},
/**
 * Initialize git-flow
 */
async gitflowInit(options: GitFlowInitOptions) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_init", { options });
},
/**
 * Start a feature branch
 */
async gitflowFeatureStart(name: string, base: string | null) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_feature_start", { name, base });
},
/**
 * Finish a feature branch
 */
async gitflowFeatureFinish(name: string, options: GitFlowFinishOptions) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_feature_finish", { name, options });
},
/**
 * Publish a feature branch
 */
async gitflowFeaturePublish(name: string) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_feature_publish", { name });
},
/**
 * List feature branches
 */
async gitflowFeatureList() : Promise<string[]> {
    return await TAURI_INVOKE("gitflow_feature_list");
},
/**
 * Start a release branch
 */
async gitflowReleaseStart(name: string, base: string | null) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_release_start", { name, base });
},
/**
 * Finish a release branch
 */
async gitflowReleaseFinish(name: string, options: GitFlowFinishOptions) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_release_finish", { name, options });
},
/**
 * Publish a release branch
 */
async gitflowReleasePublish(name: string) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_release_publish", { name });
},
/**
 * List release branches
 */
async gitflowReleaseList() : Promise<string[]> {
    return await TAURI_INVOKE("gitflow_release_list");
},
/**
 * Start a hotfix branch
 */
async gitflowHotfixStart(name: string, base: string | null) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_hotfix_start", { name, base });
},
/**
 * Finish a hotfix branch
 */
async gitflowHotfixFinish(name: string, options: GitFlowFinishOptions) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_hotfix_finish", { name, options });
},
/**
 * Publish a hotfix branch
 */
async gitflowHotfixPublish(name: string) : Promise<GitFlowResult> {
    return await TAURI_INVOKE("gitflow_hotfix_publish", { name });
},
/**
 * List hotfix branches
 */
async gitflowHotfixList() : Promise<string[]> {
    return await TAURI_INVOKE("gitflow_hotfix_list");
},
/**
 * Search for content in the repository working tree
 */
async grepContent(options: GrepOptions) : Promise<GrepResult> {
    return await TAURI_INVOKE("grep_content", { options });
},
/**
 * Search for content in a specific commit
 */
async grepCommit(commitOid: string, options: GrepOptions) : Promise<GrepResult> {
    return await TAURI_INVOKE("grep_commit", { commitOid, options });
},
async getSettings() : Promise<AppSettings> {
    return await TAURI_INVOKE("get_settings");
},
async saveSettings(settings: AppSettings) : Promise<null> {
    return await TAURI_INVOKE("save_settings", { settings });
},
async getRepositorySettings() : Promise<RepositorySettings> {
    return await TAURI_INVOKE("get_repository_settings");
},
async saveRepositoryUserConfig(userName: string | null, userEmail: string | null) : Promise<null> {
    return await TAURI_INVOKE("save_repository_user_config", { userName, userEmail });
},
/**
 * List all hooks with their status
 */
async listHooks() : Promise<HookInfo[]> {
    return await TAURI_INVOKE("list_hooks");
},
/**
 * Get hook details including content
 */
async getHook(hookType: GitHookType) : Promise<HookDetails> {
    return await TAURI_INVOKE("get_hook", { hookType });
},
/**
 * Create a new hook
 */
async createHook(hookType: GitHookType, content: string) : Promise<null> {
    return await TAURI_INVOKE("create_hook", { hookType, content });
},
/**
 * Update an existing hook
 */
async updateHook(hookType: GitHookType, content: string) : Promise<null> {
    return await TAURI_INVOKE("update_hook", { hookType, content });
},
/**
 * Delete a hook
 */
async deleteHook(hookType: GitHookType) : Promise<null> {
    return await TAURI_INVOKE("delete_hook", { hookType });
},
/**
 * Toggle hook enabled/disabled state
 * Returns the new enabled state
 */
async toggleHook(hookType: GitHookType) : Promise<boolean> {
    return await TAURI_INVOKE("toggle_hook", { hookType });
},
/**
 * Get available hook templates
 */
async getHookTemplates() : Promise<HookTemplate[]> {
    return await TAURI_INVOKE("get_hook_templates");
},
/**
 * Get templates for a specific hook type
 */
async getHookTemplatesForType(hookType: GitHookType) : Promise<HookTemplate[]> {
    return await TAURI_INVOKE("get_hook_templates_for_type", { hookType });
},
async getSigningConfig() : Promise<SigningConfig> {
    return await TAURI_INVOKE("get_signing_config");
},
async listGpgKeys() : Promise<GpgKey[]> {
    return await TAURI_INVOKE("list_gpg_keys");
},
async listSshKeys() : Promise<SshKey[]> {
    return await TAURI_INVOKE("list_ssh_keys");
},
async testSigning(config: SigningConfig) : Promise<SigningTestResult> {
    return await TAURI_INVOKE("test_signing", { config });
},
async isSigningAvailable(config: SigningConfig) : Promise<boolean> {
    return await TAURI_INVOKE("is_signing_available", { config });
},
async createArchive(options: ArchiveOptions) : Promise<ArchiveResult> {
    return await TAURI_INVOKE("create_archive", { options });
},
/**
 * Create patches from a commit range using git format-patch
 */
async formatPatch(options: FormatPatchOptions) : Promise<PatchResult> {
    return await TAURI_INVOKE("format_patch", { options });
},
/**
 * Create a patch from a specific commit or staged changes
 */
async createPatch(options: CreatePatchOptions) : Promise<PatchResult> {
    return await TAURI_INVOKE("create_patch", { options });
},
/**
 * Apply a patch file (git apply)
 */
async applyPatch(options: ApplyPatchOptions) : Promise<PatchResult> {
    return await TAURI_INVOKE("apply_patch", { options });
},
/**
 * Apply patches using git am (creates commits)
 */
async applyMailbox(options: ApplyMailboxOptions) : Promise<PatchResult> {
    return await TAURI_INVOKE("apply_mailbox", { options });
},
/**
 * Abort an in-progress git am session
 */
async amAbort() : Promise<PatchResult> {
    return await TAURI_INVOKE("am_abort");
},
/**
 * Continue git am after resolving conflicts
 */
async amContinue() : Promise<PatchResult> {
    return await TAURI_INVOKE("am_continue");
},
/**
 * Skip the current patch in git am
 */
async amSkip() : Promise<PatchResult> {
    return await TAURI_INVOKE("am_skip");
},
async generateCommitMessage() : Promise<GenerateCommitMessageResponse> {
    return await TAURI_INVOKE("generate_commit_message");
},
async setAiApiKey(provider: AiProvider, apiKey: string) : Promise<null> {
    return await TAURI_INVOKE("set_ai_api_key", { provider, apiKey });
},
async hasAiApiKey(provider: AiProvider) : Promise<boolean> {
    return await TAURI_INVOKE("has_ai_api_key", { provider });
},
async deleteAiApiKey(provider: AiProvider) : Promise<null> {
    return await TAURI_INVOKE("delete_ai_api_key", { provider });
},
async testAiConnection(provider: AiProvider) : Promise<boolean> {
    return await TAURI_INVOKE("test_ai_connection", { provider });
},
async listOllamaModels(ollamaUrl: string | null) : Promise<string[]> {
    return await TAURI_INVOKE("list_ollama_models", { ollamaUrl });
},
async addToGitignore(pattern: string, gitignorePath: string) : Promise<IgnoreResult> {
    return await TAURI_INVOKE("add_to_gitignore", { pattern, gitignorePath });
},
async addToGlobalGitignore(pattern: string) : Promise<IgnoreResult> {
    return await TAURI_INVOKE("add_to_global_gitignore", { pattern });
},
async getIgnoreOptions(filePath: string) : Promise<IgnoreOptions> {
    return await TAURI_INVOKE("get_ignore_options", { filePath });
},
/**
 * Check if Git LFS is installed on the system
 */
async lfsCheckInstalled() : Promise<[boolean, string | null]> {
    return await TAURI_INVOKE("lfs_check_installed");
},
/**
 * Get Git environment information (versions, paths, LFS availability)
 */
async getGitEnvironment() : Promise<GitEnvironment> {
    return await TAURI_INVOKE("get_git_environment");
},
/**
 * Get comprehensive LFS status for the current repository
 */
async lfsStatus() : Promise<LfsStatus> {
    return await TAURI_INVOKE("lfs_status");
},
/**
 * Initialize LFS in the current repository
 */
async lfsInstall() : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_install");
},
/**
 * Track a file pattern with LFS
 */
async lfsTrack(pattern: string) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_track", { pattern });
},
/**
 * Untrack a file pattern from LFS
 */
async lfsUntrack(pattern: string) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_untrack", { pattern });
},
/**
 * List all tracked LFS patterns
 */
async lfsListPatterns() : Promise<LfsTrackedPattern[]> {
    return await TAURI_INVOKE("lfs_list_patterns");
},
/**
 * List all LFS files in the repository
 */
async lfsListFiles() : Promise<LfsFile[]> {
    return await TAURI_INVOKE("lfs_list_files");
},
/**
 * Fetch LFS objects from remote
 */
async lfsFetch(options: LfsFetchOptions) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_fetch", { options });
},
/**
 * Pull LFS objects (fetch + checkout)
 */
async lfsPull(options: LfsPullOptions) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_pull", { options });
},
/**
 * Push LFS objects to remote
 */
async lfsPush(options: LfsPushOptions) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_push", { options });
},
/**
 * Migrate files to/from LFS
 */
async lfsMigrate(options: LfsMigrateOptions) : Promise<LfsResult> {
    return await TAURI_INVOKE("lfs_migrate", { options });
},
/**
 * Get LFS environment information
 */
async lfsEnv() : Promise<LfsEnvironment> {
    return await TAURI_INVOKE("lfs_env");
},
/**
 * Check if a file is an LFS pointer
 */
async lfsIsPointer(path: string) : Promise<boolean> {
    return await TAURI_INVOKE("lfs_is_pointer", { path });
},
/**
 * Prune old LFS objects
 */
async lfsPrune(options: LfsPruneOptions) : Promise<LfsPruneResult> {
    return await TAURI_INVOKE("lfs_prune", { options });
},
/**
 * Start the OAuth flow for a provider
 */
async integrationStartOauth(provider: ProviderType) : Promise<null> {
    return await TAURI_INVOKE("integration_start_oauth", { provider });
},
/**
 * Cancel an in-progress OAuth flow
 */
async integrationCancelOauth() : Promise<null> {
    return await TAURI_INVOKE("integration_cancel_oauth");
},
async integrationIsConnected(provider: ProviderType) : Promise<boolean> {
    return await TAURI_INVOKE("integration_is_connected", { provider });
},
async integrationGetStatus(provider: ProviderType) : Promise<IntegrationStatus> {
    return await TAURI_INVOKE("integration_get_status", { provider });
},
async integrationDisconnect(provider: ProviderType) : Promise<null> {
    return await TAURI_INVOKE("integration_disconnect", { provider });
},
async integrationDetectProvider() : Promise<DetectedProvider | null> {
    return await TAURI_INVOKE("integration_detect_provider");
},
async integrationGetRepoInfo(detected: DetectedProvider) : Promise<IntegrationRepoInfo> {
    return await TAURI_INVOKE("integration_get_repo_info", { detected });
},
async integrationListPrs(detected: DetectedProvider, prState: PrState, page: number) : Promise<PullRequestsPage> {
    return await TAURI_INVOKE("integration_list_prs", { detected, prState, page });
},
async integrationGetPr(detected: DetectedProvider, number: number) : Promise<PullRequestDetail> {
    return await TAURI_INVOKE("integration_get_pr", { detected, number });
},
async integrationCreatePr(detected: DetectedProvider, options: CreatePrOptions) : Promise<PullRequest> {
    return await TAURI_INVOKE("integration_create_pr", { detected, options });
},
async integrationMergePr(detected: DetectedProvider, number: number, options: MergePrOptions) : Promise<null> {
    return await TAURI_INVOKE("integration_merge_pr", { detected, number, options });
},
async integrationListIssues(detected: DetectedProvider, issueState: IssueState, page: number) : Promise<IssuesPage> {
    return await TAURI_INVOKE("integration_list_issues", { detected, issueState, page });
},
async integrationGetIssue(detected: DetectedProvider, number: number) : Promise<IssueDetail> {
    return await TAURI_INVOKE("integration_get_issue", { detected, number });
},
async integrationCreateIssue(detected: DetectedProvider, options: CreateIssueOptions) : Promise<Issue> {
    return await TAURI_INVOKE("integration_create_issue", { detected, options });
},
async integrationListCiRuns(detected: DetectedProvider, page: number) : Promise<CiRunsPage> {
    return await TAURI_INVOKE("integration_list_ci_runs", { detected, page });
},
async integrationGetCommitStatus(detected: DetectedProvider, sha: string) : Promise<CommitStatus> {
    return await TAURI_INVOKE("integration_get_commit_status", { detected, sha });
},
async integrationListNotifications(detected: DetectedProvider, all: boolean, page: number) : Promise<NotificationsPage> {
    return await TAURI_INVOKE("integration_list_notifications", { detected, all, page });
},
async integrationMarkNotificationRead(provider: ProviderType, threadId: string) : Promise<null> {
    return await TAURI_INVOKE("integration_mark_notification_read", { provider, threadId });
},
async integrationMarkAllNotificationsRead(detected: DetectedProvider) : Promise<null> {
    return await TAURI_INVOKE("integration_mark_all_notifications_read", { detected });
},
async integrationGetUnreadCount(detected: DetectedProvider) : Promise<number> {
    return await TAURI_INVOKE("integration_get_unread_count", { detected });
},
/**
 * Get avatar for a commit author
 * If sha provided and integration connected, fetches avatar from provider API
 */
async getAvatar(email: string, sha: string | null) : Promise<AvatarResponse> {
    return await TAURI_INVOKE("get_avatar", { email, sha });
},
/**
 * Clear the avatar cache
 */
async clearAvatarCache() : Promise<null> {
    return await TAURI_INVOKE("clear_avatar_cache");
},
/**
 * List all global actions
 */
async listGlobalActions() : Promise<CustomAction[]> {
    return await TAURI_INVOKE("list_global_actions");
},
/**
 * Save a global action (create or update)
 */
async saveGlobalAction(action: CustomAction) : Promise<null> {
    return await TAURI_INVOKE("save_global_action", { action });
},
/**
 * Delete a global action
 */
async deleteGlobalAction(actionId: string) : Promise<null> {
    return await TAURI_INVOKE("delete_global_action", { actionId });
},
/**
 * List all repository-specific actions
 */
async listRepoActions() : Promise<CustomAction[]> {
    return await TAURI_INVOKE("list_repo_actions");
},
/**
 * Save a repository-specific action (create or update)
 */
async saveRepoAction(action: CustomAction) : Promise<null> {
    return await TAURI_INVOKE("save_repo_action", { action });
},
/**
 * Delete a repository-specific action
 */
async deleteRepoAction(actionId: string) : Promise<null> {
    return await TAURI_INVOKE("delete_repo_action", { actionId });
},
/**
 * Get all actions for a specific context (merged global + repo)
 */
async getActionsForContext(context: ActionContext) : Promise<CustomAction[]> {
    return await TAURI_INVOKE("get_actions_for_context", { context });
},
/**
 * Get all actions (merged global + repo, unfiltered)
 */
async getAllActions() : Promise<CustomAction[]> {
    return await TAURI_INVOKE("get_all_actions");
},
/**
 * Execute a custom action
 */
async executeCustomAction(actionId: string, variables: ActionVariables) : Promise<ActionExecutionResult> {
    return await TAURI_INVOKE("execute_custom_action", { actionId, variables });
}
}

/** user-defined events **/


export const events = __makeEvents__<{
filesChangedEvent: FilesChangedEvent,
gitOperationProgressEvent: GitOperationProgressEvent,
headChangedEvent: HeadChangedEvent,
indexChangedEvent: IndexChangedEvent,
integrationStatusChangedEvent: IntegrationStatusChangedEvent,
menuActionEvent: MenuActionEvent,
oAuthCallbackEvent: OAuthCallbackEvent,
refChangedEvent: RefChangedEvent,
remoteFetchedEvent: RemoteFetchedEvent,
repositoryDirtyEvent: RepositoryDirtyEvent,
watchErrorEvent: WatchErrorEvent
}>({
filesChangedEvent: "files-changed-event",
gitOperationProgressEvent: "git-operation-progress-event",
headChangedEvent: "head-changed-event",
indexChangedEvent: "index-changed-event",
integrationStatusChangedEvent: "integration-status-changed-event",
menuActionEvent: "menu-action-event",
oAuthCallbackEvent: "o-auth-callback-event",
refChangedEvent: "ref-changed-event",
remoteFetchedEvent: "remote-fetched-event",
repositoryDirtyEvent: "repository-dirty-event",
watchErrorEvent: "watch-error-event"
})

/** user-defined constants **/



/** user-defined types **/

/**
 * Context where a custom action can appear
 */
export type ActionContext = 
/**
 * File in staging area (staged or unstaged)
 */
"File" | 
/**
 * Commit in history
 */
"Commit" | 
/**
 * Branch (local or remote)
 */
"Branch" | 
/**
 * Tag
 */
"Tag" | 
/**
 * Stash entry
 */
"Stash" | 
/**
 * Repository-wide (available everywhere)
 */
"Repository"
/**
 * Result of executing a custom action
 */
export type ActionExecutionResult = { 
/**
 * Exit code from command (0 = success)
 */
exitCode: number; 
/**
 * Standard output
 */
stdout: string; 
/**
 * Standard error
 */
stderr: string; 
/**
 * Execution time in milliseconds
 */
durationMs: number }
/**
 * Storage location for actions
 */
export type ActionStorageType = 
/**
 * Global actions stored in app database
 */
"Global" | 
/**
 * Per-repository actions stored in .axis/actions.json
 */
"Repository"
/**
 * Variables available for substitution in commands
 */
export type ActionVariables = { 
/**
 * Repository root path
 */
repoPath: string; 
/**
 * Current branch name
 */
branch: string | null; 
/**
 * Selected file path (relative)
 */
file: string | null; 
/**
 * Multiple selected files (space-separated, quoted)
 */
selectedFiles: string | null; 
/**
 * Commit hash (full SHA)
 */
commitHash: string | null; 
/**
 * Commit hash (short, 7 chars)
 */
commitShort: string | null; 
/**
 * Commit message (first line)
 */
commitMessage: string | null; 
/**
 * Remote URL (origin)
 */
remoteUrl: string | null; 
/**
 * Tag name
 */
tag: string | null; 
/**
 * Stash reference (e.g., stash@{0})
 */
stashRef: string | null }
/**
 * Options for adding a submodule
 */
export type AddSubmoduleOptions = { 
/**
 * URL of the repository to add
 */
url: string; 
/**
 * Path where to add the submodule
 */
path: string; 
/**
 * Branch to track (default: default branch of remote)
 */
branch: string | null; 
/**
 * Custom name for the submodule (default: derived from path)
 */
name: string | null; 
/**
 * Clone depth (shallow clone)
 */
depth: number | null }
/**
 * Options for adding a worktree
 */
export type AddWorktreeOptions = { 
/**
 * Path where to create the worktree
 */
path: string; 
/**
 * Branch to checkout (creates new branch if create_branch is true)
 */
branch: string | null; 
/**
 * Create a new branch with this name
 */
createBranch: boolean; 
/**
 * Commit/branch to base new branch on (if create_branch is true)
 */
base: string | null; 
/**
 * Force creation even if branch is checked out elsewhere
 */
force: boolean; 
/**
 * Create worktree in detached HEAD state
 */
detach: boolean }
export type AiProvider = "OpenAi" | "Anthropic" | "Ollama"
export type AppSettings = { theme: Theme; language: string; fontSize: number; showLineNumbers: boolean; autoFetchInterval: number; confirmBeforeDiscard: boolean; signCommits: boolean; bypassHooks: boolean; signingFormat: SigningFormat; signingKey: string | null; gpgProgram: string | null; sshProgram: string | null; diffContextLines: number; diffWordWrap: boolean; diffSideBySide: boolean; spellCheckCommitMessages: boolean; conventionalCommitsEnabled: boolean; conventionalCommitsScopes: string[] | null; aiEnabled: boolean; aiProvider: AiProvider; aiModel: string | null; aiOllamaUrl: string | null; notificationHistoryCapacity: number; gravatarEnabled: boolean }
/**
 * Options for applying mailbox patches (git am)
 */
export type ApplyMailboxOptions = { 
/**
 * Paths to patch files
 */
patchPaths: string[]; 
/**
 * Use 3-way merge if patch doesn't apply cleanly
 */
threeWay: boolean }
/**
 * Options for applying a patch
 */
export type ApplyPatchOptions = { 
/**
 * Path to the patch file
 */
patchPath: string; 
/**
 * Only check if patch can be applied, don't actually apply
 */
checkOnly: boolean; 
/**
 * Use 3-way merge if patch doesn't apply cleanly
 */
threeWay: boolean }
/**
 * Options for creating an archive
 */
export type ArchiveOptions = { 
/**
 * The reference to archive (commit SHA, branch name, tag)
 */
reference: string; 
/**
 * Archive format: zip, tar, tar.gz, tar.bz2
 */
format: string; 
/**
 * Output file path
 */
outputPath: string; 
/**
 * Optional prefix for files in the archive
 */
prefix: string | null }
/**
 * Result of an archive operation
 */
export type ArchiveResult = { message: string; outputPath: string | null; sizeBytes: number | null }
export type AvatarResponse = { source: AvatarSource; path: string | null }
export type AvatarSource = "Integration" | "Gravatar" | "Default"
export type AxisError = { type: "RepositoryNotFound"; data: string } | { type: "RepositoryAlreadyOpen"; data: string } | { type: "InvalidRepositoryPath"; data: string } | { type: "GitError"; data: string } | { type: "IoError"; data: string } | { type: "DatabaseError"; data: string } | { type: "SerializationError"; data: string } | { type: "InvalidReference"; data: string } | { type: "NoRepositoryOpen" } | { type: "BranchNotFound"; data: string } | { type: "BranchNotMerged"; data: string } | { type: "RemoteNotFound"; data: string } | { type: "FileNotFound"; data: string } | { type: "CannotFastForward" } | { type: "RebaseRequired" } | { type: "MergeConflict" } | { type: "CheckoutConflict"; data: string[] } | { type: "StashApplyConflict"; data: string[] } | { type: "AuthenticationFailed"; data: string } | { type: "AiServiceError"; data: string } | { type: "ApiKeyNotConfigured"; data: string } | { type: "DiffTooLarge"; data: number } | { type: "Other"; data: string } | { type: "IntegrationNotConnected"; data: string } | { type: "IntegrationError"; data: string } | { type: "ProviderNotDetected" } | { type: "OAuthError"; data: string } | { type: "OAuthCancelled" }
/**
 * Mark type for bisect marking operations
 */
export type BisectMarkType = 
/**
 * Mark commit as good
 */
"Good" | 
/**
 * Mark commit as bad
 */
"Bad" | 
/**
 * Skip this commit (cannot be tested)
 */
"Skip"
/**
 * Result of a bisect operation step
 */
export type BisectResult = { 
/**
 * Whether the operation was successful
 */
success: boolean; 
/**
 * Current bisect state
 */
state: BisectState; 
/**
 * Informational message
 */
message: string }
/**
 * Options for starting a bisect session
 */
export type BisectStartOptions = { 
/**
 * The known bad commit (defaults to HEAD if not specified)
 */
badCommit: string | null; 
/**
 * The known good commit
 */
goodCommit: string }
/**
 * Current state of the bisect session
 */
export type BisectState = { 
/**
 * Whether bisect is in progress
 */
isActive: boolean; 
/**
 * Current commit being tested (if any)
 */
currentCommit: string | null; 
/**
 * Number of remaining steps (approximate)
 */
stepsRemaining: number | null; 
/**
 * Total commits in range
 */
totalCommits: number | null; 
/**
 * The bad commit
 */
badCommit: string | null; 
/**
 * The good commit(s)
 */
goodCommits: string[]; 
/**
 * Skipped commits
 */
skippedCommits: string[]; 
/**
 * The first bad commit (when bisect completes)
 */
firstBadCommit: string | null }
/**
 * A single line in a blame result
 */
export type BlameLine = { 
/**
 * Line number (1-indexed)
 */
lineNumber: number; 
/**
 * The commit OID that last modified this line
 */
commitOid: string; 
/**
 * Short commit OID
 */
shortOid: string; 
/**
 * Author name
 */
author: string; 
/**
 * When the line was last modified
 */
timestamp: string; 
/**
 * The actual line content
 */
content: string; 
/**
 * Original line number in the commit
 */
originalLine: number; 
/**
 * Whether this is the first line of a group from the same commit
 */
isGroupStart: boolean }
/**
 * Blame information for a file
 */
export type BlameResult = { path: string; lines: BlameLine[] }
export type Branch = { name: string; fullName: string; branchType: BranchType; isHead: boolean; upstream: string | null; ahead: number | null; behind: number | null; targetOid: string; lastCommitSummary: string; lastCommitTime: string }
/**
 * Result of comparing two branches
 */
export type BranchCompareResult = { 
/**
 * The base reference (e.g., current branch name)
 */
baseRef: string; 
/**
 * The compare reference (e.g., feature branch name)
 */
compareRef: string; 
/**
 * OID of the base branch tip
 */
baseOid: string; 
/**
 * OID of the compare branch tip
 */
compareOid: string; 
/**
 * OID of the merge base (common ancestor), if found
 */
mergeBaseOid: string | null; 
/**
 * Commits in compare branch but not in base (ahead)
 */
aheadCommits: Commit[]; 
/**
 * Commits in base branch but not in compare (behind)
 */
behindCommits: Commit[]; 
/**
 * Aggregate file changes from merge_base to compare branch
 */
files: FileDiff[] }
export type BranchFilter = { includeLocal: boolean; includeRemote: boolean }
export type BranchFilterType = "All" | "Current" | { Specific: string }
export type BranchType = "Local" | "Remote"
/**
 * CI/CD run conclusion
 */
export type CIConclusion = "Success" | "Failure" | "Cancelled" | "Skipped" | "Neutral" | "TimedOut" | "ActionRequired"
/**
 * CI/CD workflow run
 */
export type CIRun = { provider: ProviderType; id: string; name: string; status: CIRunStatus; conclusion: CIConclusion | null; commitSha: string; branch: string | null; event: string; createdAt: string; updatedAt: string; url: string }
/**
 * CI/CD run status
 */
export type CIRunStatus = "Queued" | "InProgress" | "Completed"
/**
 * Options for checkout operations
 */
export type CheckoutOptions = { 
/**
 * Create a new branch if it doesn't exist
 */
create: boolean; 
/**
 * Force checkout, discarding local changes
 */
force: boolean; 
/**
 * Track the remote branch when creating
 */
track: string | null }
/**
 * Options for cherry-pick operations
 */
export type CherryPickOptions = { 
/**
 * Commit(s) to cherry-pick
 */
commits: string[]; 
/**
 * If true, don't create commits (stage changes only)
 */
noCommit: boolean; 
/**
 * If true, allow empty commits
 */
allowEmpty: boolean }
/**
 * Result of a cherry-pick operation
 */
export type CherryPickResult = { 
/**
 * Whether the cherry-pick was successful
 */
success: boolean; 
/**
 * New commit OIDs created
 */
commitOids: string[]; 
/**
 * Conflicted files if cherry-pick has conflicts
 */
conflicts: ConflictedFile[]; 
/**
 * Informational message
 */
message: string }
/**
 * Paginated CI runs response
 */
export type CiRunsPage = { runs: CIRun[]; hasMore: boolean }
export type Commit = { oid: string; shortOid: string; message: string; summary: string; author: Signature; committer: Signature; parentOids: string[]; timestamp: string; isMerge: boolean; 
/**
 * Signature info if the commit is signed
 */
signature: CommitSignature | null }
/**
 * A reference (branch or tag) pointing to a commit
 */
export type CommitRef = { name: string; refType: RefType; isHead: boolean }
/**
 * Information about a commit's cryptographic signature
 */
export type CommitSignature = { 
/**
 * The type of signature (GPG or SSH), None if unknown
 */
format: SigningFormat | null; 
/**
 * Whether the signature was verified
 */
verified: boolean; 
/**
 * The signer info (if verified)
 */
signer: string | null }
/**
 * Commit status with all checks
 */
export type CommitStatus = { state: CommitStatusState; checks: CIRun[]; totalCount: number }
/**
 * Combined commit status
 */
export type CommitStatusState = "Pending" | "Success" | "Failure" | "Error"
/**
 * Three-way content for conflict resolution
 */
export type ConflictContent = { 
/**
 * Path to the file
 */
path: string; 
/**
 * Base (ancestor) content
 */
base: string | null; 
/**
 * Ours (current branch) content
 */
ours: string | null; 
/**
 * Theirs (incoming) content
 */
theirs: string | null; 
/**
 * Current working tree content with conflict markers
 */
merged: string }
/**
 * Which version to use when resolving a conflict
 */
export type ConflictResolution = 
/**
 * Use our version
 */
"Ours" | 
/**
 * Use their version
 */
"Theirs" | 
/**
 * Use custom merged content
 */
"Merged"
/**
 * Type of conflict
 */
export type ConflictType = 
/**
 * Content conflict (both sides modified)
 */
"Content" | 
/**
 * File deleted on one side, modified on other
 */
"DeleteModify" | 
/**
 * File added on both sides with different content
 */
"AddAdd" | 
/**
 * File renamed differently on both sides
 */
"RenameRename" | 
/**
 * File renamed and modified
 */
"RenameModify" | 
/**
 * Binary file conflict
 */
"Binary"
/**
 * Information about a conflicted file
 */
export type ConflictedFile = { 
/**
 * Path to the conflicted file
 */
path: string; 
/**
 * Type of conflict
 */
conflictType: ConflictType; 
/**
 * Whether the file has been resolved
 */
isResolved: boolean }
/**
 * Options for branch creation
 */
export type CreateBranchOptions = { 
/**
 * The starting point (commit/branch/tag). If None, uses HEAD.
 */
startPoint: string | null; 
/**
 * Force creation even if branch exists
 */
force: boolean; 
/**
 * Set up tracking for an upstream branch
 */
track: string | null }
/**
 * Options for creating an issue
 */
export type CreateIssueOptions = { title: string; body: string | null; labels: string[]; assignees: string[] }
/**
 * Options for creating patches
 */
export type CreatePatchOptions = { 
/**
 * The commit SHA to create patch from (None = staged changes)
 */
commitOid: string | null; 
/**
 * Output directory for patch files
 */
outputDir: string }
/**
 * Options for creating a pull request
 */
export type CreatePrOptions = { title: string; body: string | null; sourceBranch: string; targetBranch: string; draft: boolean }
/**
 * Options for creating a tag
 */
export type CreateTagOptions = { 
/**
 * Target ref/commit (default: HEAD)
 */
target: string | null; 
/**
 * Create an annotated tag
 */
annotated: boolean; 
/**
 * Tag message (required for annotated tags)
 */
message: string | null; 
/**
 * Force overwrite existing tag
 */
force: boolean }
/**
 * Custom action definition
 */
export type CustomAction = { 
/**
 * Unique identifier (UUID)
 */
id: string; 
/**
 * Display name shown in menus
 */
name: string; 
/**
 * Optional description/tooltip
 */
description: string | null; 
/**
 * Shell command to execute (supports variable substitution)
 */
command: string; 
/**
 * Working directory (defaults to repo path)
 */
workingDir: string | null; 
/**
 * Contexts where this action appears
 */
contexts: ActionContext[]; 
/**
 * Keyboard shortcut (e.g., "mod+shift+1")
 */
shortcut: string | null; 
/**
 * Show confirmation dialog before execution
 */
confirm: boolean; 
/**
 * Custom confirmation message
 */
confirmMessage: string | null; 
/**
 * Show output dialog after execution
 */
showOutput: boolean; 
/**
 * Whether action is enabled
 */
enabled: boolean; 
/**
 * Sort order for menu display
 */
order: number; 
/**
 * Storage type (global or repository)
 */
storage?: ActionStorageType | null }
/**
 * Detected provider from remote URL
 */
export type DetectedProvider = { provider: ProviderType; owner: string; repo: string }
/**
 * A hunk within a diff (a contiguous block of changes)
 */
export type DiffHunk = { header: string; oldStart: number; oldLines: number; newStart: number; newLines: number; lines: DiffLine[] }
/**
 * A single line within a diff hunk
 */
export type DiffLine = { lineType: DiffLineType; content: string; oldLineNo: number | null; newLineNo: number | null }
export type DiffLineType = "Context" | "Addition" | "Deletion" | "Header" | "Binary"
/**
 * Options for generating diffs
 */
export type DiffOptions = { 
/**
 * Number of context lines around changes
 */
contextLines: number | null; 
/**
 * Ignore whitespace changes
 */
ignoreWhitespace: boolean | null; 
/**
 * Ignore whitespace at end of line
 */
ignoreWhitespaceEol: boolean | null }
/**
 * The type of change for a file in a diff
 */
export type DiffStatus = "Added" | "Deleted" | "Modified" | "Renamed" | "Copied" | "TypeChanged" | "Untracked" | "Conflicted"
/**
 * Types of diffs we can generate
 */
export type DiffTarget = 
/**
 * Diff between working directory and index (unstaged changes)
 */
"WorkdirToIndex" | 
/**
 * Diff between index and HEAD (staged changes)
 */
"IndexToHead" | 
/**
 * Diff between working directory and HEAD (all uncommitted changes)
 */
"WorkdirToHead" | 
/**
 * Diff between two commits
 */
{ CommitToCommit: { from: string; to: string } } | 
/**
 * Diff for a single commit (commit vs its parent)
 */
{ Commit: { oid: string } }
/**
 * Type of edge in the commit graph
 */
export type EdgeType = 
/**
 * Straight line (same lane)
 */
"Straight" | 
/**
 * Merge edge (coming from a different lane)
 */
"Merge" | 
/**
 * Branch edge (going to a different lane)
 */
"Branch" | 
/**
 * Merge preview edge (dashed line showing merge source)
 */
"MergePreview"
/**
 * Options for fetch operations
 */
export type FetchOptions = { 
/**
 * Prune remote tracking branches that no longer exist
 */
prune: boolean; 
/**
 * Fetch tags
 */
tags: boolean; 
/**
 * Depth for shallow fetch (None for full fetch)
 */
depth: number | null }
/**
 * Progress information for fetch operations
 */
export type FetchProgress = { totalObjects: number; indexedObjects: number; receivedObjects: number; localObjects: number; totalDeltas: number; indexedDeltas: number; receivedBytes: number }
/**
 * Result of a fetch operation
 */
export type FetchResult = { remote: string; updatedRefs: UpdatedRef[]; stats: FetchProgress }
/**
 * Represents a complete diff for a file
 */
export type FileDiff = { oldPath: string | null; newPath: string | null; oldOid: string | null; newOid: string | null; status: DiffStatus; binary: boolean; hunks: DiffHunk[]; 
/**
 * Summary statistics
 */
additions: number; deletions: number }
/**
 * Options for file history (log for specific files)
 */
export type FileLogOptions = { 
/**
 * Paths to filter commits by
 */
paths: string[]; 
/**
 * Maximum number of commits to return
 */
limit: number | null; 
/**
 * Number of commits to skip (for pagination)
 */
skip: number | null; 
/**
 * Follow file renames
 */
followRenames?: boolean }
/**
 * Result of file history query
 */
export type FileLogResult = { 
/**
 * Commits that modified the specified files
 */
commits: Commit[]; 
/**
 * Whether there are more commits
 */
hasMore: boolean }
export type FileStatus = { path: string; status: StatusType; stagedStatus: StatusType | null; unstagedStatus: StatusType | null; isConflict: boolean; oldPath: string | null }
/**
 * Files in the repository changed
 */
export type FilesChangedEvent = { paths: string[] }
/**
 * Options for format-patch (creating patches from commit range)
 */
export type FormatPatchOptions = { 
/**
 * Range specification (e.g., "HEAD~3", "main..feature", "abc123")
 */
range: string; 
/**
 * Output directory for patch files
 */
outputDir: string }
export type GenerateCommitMessageResponse = { message: string; modelUsed: string }
/**
 * Git environment information for settings display
 */
export type GitEnvironment = { 
/**
 * Git CLI version
 */
gitVersion: string | null; 
/**
 * Path to Git executable
 */
gitPath: string | null; 
/**
 * libgit2 version used by the application
 */
libgit2Version: string; 
/**
 * Whether Git LFS is installed
 */
lfsInstalled: boolean; 
/**
 * Git LFS version if installed
 */
lfsVersion: string | null }
/**
 * Git-flow configuration
 */
export type GitFlowConfig = { master: string; develop: string; featurePrefix: string; releasePrefix: string; hotfixPrefix: string; supportPrefix: string; versionTagPrefix: string }
/**
 * Options for finishing a feature/release/hotfix
 */
export type GitFlowFinishOptions = { fetch?: boolean; rebase?: boolean; keep?: boolean; forceDelete?: boolean; squash?: boolean; noFf?: boolean; message?: string | null; tagMessage?: string | null; push?: boolean }
/**
 * Options for initializing git-flow
 */
export type GitFlowInitOptions = { master?: string | null; develop?: string | null; featurePrefix?: string | null; releasePrefix?: string | null; hotfixPrefix?: string | null; supportPrefix?: string | null; versionTagPrefix?: string | null; force?: boolean }
/**
 * Result of a git-flow operation
 */
export type GitFlowResult = { success: boolean; message: string; branch: string | null }
/**
 * Git hook types
 */
export type GitHookType = 
/**
 * Runs before commit starts
 */
"PreCommit" | 
/**
 * Can modify commit message
 */
"PrepareCommitMsg" | 
/**
 * Validates commit message
 */
"CommitMsg" | 
/**
 * Runs after commit
 */
"PostCommit" | 
/**
 * Runs before push
 */
"PrePush" | 
/**
 * Runs after merge
 */
"PostMerge" | 
/**
 * Runs before rebase
 */
"PreRebase" | 
/**
 * Runs after checkout
 */
"PostCheckout" | 
/**
 * Runs after amend/rebase
 */
"PostRewrite"
/**
 * Progress update for git operations (clone, fetch, push, pull)
 */
export type GitOperationProgressEvent = { operationId: string; operationType: GitOperationType; stage: ProgressStage; totalObjects: number | null; receivedObjects: number | null; indexedObjects: number | null; receivedBytes: number; totalDeltas: number | null; indexedDeltas: number | null; message: string | null }
export type GitOperationType = "Clone" | "Fetch" | "Push" | "Pull"
/**
 * Represents a GPG key available for signing
 */
export type GpgKey = { 
/**
 * Key ID (short or long form)
 */
keyId: string; 
/**
 * User ID (name and email)
 */
userId: string; 
/**
 * Email address extracted from user_id
 */
email: string | null; 
/**
 * Whether this is the default key
 */
isDefault: boolean }
/**
 * A commit with graph layout information for visualization
 */
export type GraphCommit = 
/**
 * The underlying commit data
 */
({ oid: string; shortOid: string; message: string; summary: string; author: Signature; committer: Signature; parentOids: string[]; timestamp: string; isMerge: boolean; 
/**
 * Signature info if the commit is signed
 */
signature: CommitSignature | null }) & { 
/**
 * The lane (column) this commit occupies
 */
lane: number; 
/**
 * Connections to parent commits
 */
parentEdges: GraphEdge[]; 
/**
 * Branch/tag refs pointing to this commit
 */
refs: CommitRef[] }
/**
 * An edge connecting a commit to its parent in the graph
 */
export type GraphEdge = { 
/**
 * The parent commit OID
 */
parentOid: string; 
/**
 * The lane of the parent commit
 */
parentLane: number; 
/**
 * The type of edge (straight, merge, branch)
 */
edgeType: EdgeType }
/**
 * Options for graph generation
 */
export type GraphOptions = { 
/**
 * Maximum number of commits to include
 */
limit: number | null; 
/**
 * Number of commits to skip (for pagination)
 */
skip: number | null; 
/**
 * Start from a specific ref
 */
fromRef: string | null; 
/**
 * Include all branches (not just current) - deprecated, use branch_filter instead
 */
allBranches?: boolean; 
/**
 * Branch filter (all, current, or specific branch)
 */
branchFilter?: BranchFilterType; 
/**
 * Whether to include remote branches
 */
includeRemotes?: boolean; 
/**
 * Sort order for commits
 */
sortOrder?: SortOrder; 
/**
 * Whether to include uncommitted changes as first entry
 */
includeUncommitted?: boolean }
/**
 * Result of graph generation with metadata
 */
export type GraphResult = { 
/**
 * The commits with graph layout
 */
commits: GraphCommit[]; 
/**
 * Total number of commits (for pagination)
 */
totalCount: number; 
/**
 * Maximum lane used (for graph width calculation)
 */
maxLane: number; 
/**
 * Whether there are more commits
 */
hasMore: boolean }
/**
 * A single grep match
 */
export type GrepMatch = { path: string; lineNumber: number | null; content: string }
/**
 * Content search options
 */
export type GrepOptions = { pattern: string; paths?: string[]; ignoreCase?: boolean; wordRegexp?: boolean; extendedRegexp?: boolean; invertMatch?: boolean; showLineNumbers?: boolean; maxCount?: number | null; contextLines?: number | null }
/**
 * Result of a grep search
 */
export type GrepResult = { matches: GrepMatch[]; totalMatches: number }
/**
 * HEAD changed (checkout, commit)
 */
export type HeadChangedEvent = null
/**
 * Hook with content for editing
 */
export type HookDetails = { 
/**
 * Hook info
 */
info: HookInfo; 
/**
 * Content of the hook file (None if file doesn't exist)
 */
content: string | null }
/**
 * Hook info for management UI
 */
export type HookInfo = { 
/**
 * Type of hook
 */
hookType: GitHookType; 
/**
 * Whether the hook file exists
 */
exists: boolean; 
/**
 * Whether the hook is enabled (false if has .disabled suffix)
 */
enabled: boolean; 
/**
 * Full path to the hook file
 */
path: string; 
/**
 * Whether the hook file is executable (Unix only, always true on Windows)
 */
isExecutable: boolean }
/**
 * Template for creating hooks
 */
export type HookTemplate = { 
/**
 * Template name
 */
name: string; 
/**
 * Human-readable description
 */
description: string; 
/**
 * Hook type this template is for
 */
hookType: GitHookType; 
/**
 * Template content (shell script)
 */
content: string }
/**
 * Options for ignoring a file, returned by get_ignore_options
 */
export type IgnoreOptions = { 
/**
 * List of ancestor .gitignore files (relative paths from repo root)
 * Always includes ".gitignore" (root), plus any existing .gitignore files
 * in the path hierarchy of the target file
 */
gitignoreFiles: string[]; 
/**
 * Default .gitignore file to use (closest existing ancestor)
 */
defaultGitignore: string; 
/**
 * Suggested patterns for the file
 */
suggestions: IgnoreSuggestion[] }
/**
 * Result of adding a pattern to .gitignore
 */
export type IgnoreResult = { 
/**
 * Human-readable message about the operation
 */
message: string; 
/**
 * The pattern that was added
 */
pattern: string; 
/**
 * Path to the .gitignore file that was modified
 */
gitignorePath: string; 
/**
 * Whether the pattern already existed (no changes made)
 */
alreadyExisted: boolean }
/**
 * A suggested pattern for ignoring a file
 */
export type IgnoreSuggestion = { 
/**
 * The pattern to add to .gitignore
 */
pattern: string; 
/**
 * Description of what this pattern does
 */
description: string; 
/**
 * Type of the suggestion
 */
suggestionType: IgnoreSuggestionType }
/**
 * Type of ignore pattern suggestion
 */
export type IgnoreSuggestionType = 
/**
 * Exact file path (e.g., "src/foo/bar.txt")
 */
"ExactFile" | 
/**
 * File extension (e.g., "*.txt")
 */
"Extension" | 
/**
 * Directory (e.g., "src/foo/")
 */
"Directory" | 
/**
 * File name anywhere (e.g., "bar.txt")
 */
"FileName"
/**
 * The index (staging area) changed
 */
export type IndexChangedEvent = null
/**
 * Label from integration provider
 */
export type IntegrationLabel = { name: string; color: string; description: string | null }
/**
 * Repository information from the integration provider
 */
export type IntegrationRepoInfo = { provider: ProviderType; owner: string; name: string; fullName: string; description: string | null; stars: number; forks: number; openIssuesCount: number; isPrivate: boolean; defaultBranch: string; url: string }
/**
 * Integration connection status
 */
export type IntegrationStatus = { provider: ProviderType; connected: boolean; username: string | null; avatarUrl: string | null }
/**
 * Integration connection status changed
 */
export type IntegrationStatusChangedEvent = { provider: ProviderType; connected: boolean }
/**
 * User from integration provider
 */
export type IntegrationUser = { login: string; avatarUrl: string; url: string }
/**
 * A single entry in the interactive rebase todo list
 */
export type InteractiveRebaseEntry = { 
/**
 * The action to perform
 */
action: RebaseAction; 
/**
 * Commit short OID
 */
shortOid: string; 
/**
 * Commit full OID
 */
oid: string; 
/**
 * Commit message summary
 */
summary: string; 
/**
 * Original index for tracking reordering
 */
originalIndex: number }
/**
 * Options for starting an interactive rebase
 */
export type InteractiveRebaseOptions = { 
/**
 * The branch/commit to rebase onto
 */
onto: string; 
/**
 * The ordered list of entries with actions
 */
entries: InteractiveRebaseEntry[]; 
/**
 * Whether to autosquash fixup! commits
 */
autosquash: boolean }
/**
 * Extended rebase preview with interactive entries
 */
export type InteractiveRebasePreview = { 
/**
 * Base preview data
 */
preview: RebasePreview; 
/**
 * Entries prepared for interactive editing (with default pick action)
 */
entries: InteractiveRebaseEntry[] }
/**
 * Issue summary for list views
 */
export type Issue = { provider: ProviderType; number: number; title: string; state: IssueState; author: IntegrationUser; labels: IntegrationLabel[]; commentsCount: number; createdAt: string; updatedAt: string; url: string }
/**
 * Detailed issue information
 */
export type IssueDetail = ({ provider: ProviderType; number: number; title: string; state: IssueState; author: IntegrationUser; labels: IntegrationLabel[]; commentsCount: number; createdAt: string; updatedAt: string; url: string }) & { body: string | null; assignees: IntegrationUser[]; milestone: string | null }
/**
 * Issue state
 */
export type IssueState = "Open" | "Closed" | "All"
/**
 * Paginated issues response
 */
export type IssuesPage = { items: Issue[]; hasMore: boolean }
/**
 * LFS environment information
 */
export type LfsEnvironment = { 
/**
 * LFS version
 */
version: string; 
/**
 * Git LFS endpoint URL
 */
endpoint: string | null; 
/**
 * Local LFS storage path
 */
storagePath: string | null; 
/**
 * Whether SSH is used for transfers
 */
usesSsh: boolean }
/**
 * Options for LFS fetch operation
 */
export type LfsFetchOptions = { 
/**
 * Fetch LFS objects for all refs
 */
all: boolean; 
/**
 * Fetch only recent LFS objects
 */
recent: boolean; 
/**
 * Include objects for the specified remote
 */
remote: string | null; 
/**
 * Specific refs to fetch (branches, tags)
 */
refs: string[] }
/**
 * An LFS-tracked file
 */
export type LfsFile = { 
/**
 * Path to the file relative to repository root
 */
path: string; 
/**
 * LFS object ID (SHA-256)
 */
oid: string; 
/**
 * File size in bytes
 */
size: number; 
/**
 * Whether the file content is downloaded
 */
isDownloaded: boolean; 
/**
 * File status
 */
status: LfsFileStatus }
/**
 * Status of an LFS file
 */
export type LfsFileStatus = 
/**
 * File content is downloaded locally
 */
"Downloaded" | 
/**
 * File is a pointer (content not downloaded)
 */
"Pointer" | 
/**
 * File is not tracked by LFS
 */
"NotLfs" | 
/**
 * Status unknown
 */
"Unknown"
/**
 * LFS migration mode
 */
export type LfsMigrateMode = 
/**
 * Import files into LFS
 */
"Import" | 
/**
 * Export files from LFS to regular Git
 */
"Export" | 
/**
 * Show migration info without making changes
 */
"Info"
/**
 * Options for LFS migrate operation
 */
export type LfsMigrateOptions = { 
/**
 * Migration mode: import or export
 */
mode: LfsMigrateMode; 
/**
 * File patterns to include
 */
include: string[]; 
/**
 * File patterns to exclude
 */
exclude: string[]; 
/**
 * Include all refs
 */
everything: boolean; 
/**
 * Specific refs to migrate
 */
refs: string[]; 
/**
 * Rewrite history (use with caution)
 */
above: number | null }
/**
 * Options for LFS prune operation
 */
export type LfsPruneOptions = { 
/**
 * Dry run - show what would be pruned
 */
dryRun: boolean; 
/**
 * Verify remote copies before pruning
 */
verifyRemote: boolean }
/**
 * Result of LFS prune operation
 */
export type LfsPruneResult = { 
/**
 * Whether the operation succeeded
 */
success: boolean; 
/**
 * Message describing the result
 */
message: string; 
/**
 * Number of objects pruned
 */
objectsPruned: number; 
/**
 * Space reclaimed in bytes
 */
spaceReclaimed: number }
/**
 * Options for LFS pull operation
 */
export type LfsPullOptions = { 
/**
 * Remote to pull from
 */
remote: string | null }
/**
 * Options for LFS push operation
 */
export type LfsPushOptions = { 
/**
 * Remote to push to
 */
remote: string | null; 
/**
 * Push all local LFS objects
 */
all: boolean; 
/**
 * Dry run - don't actually push
 */
dryRun: boolean }
/**
 * Result of an LFS operation
 */
export type LfsResult = { 
/**
 * Whether the operation succeeded
 */
success: boolean; 
/**
 * Message describing the result
 */
message: string; 
/**
 * Files affected by the operation
 */
affectedFiles: string[] }
/**
 * Status of Git LFS in the repository
 */
export type LfsStatus = { 
/**
 * Whether git-lfs is installed on the system
 */
isInstalled: boolean; 
/**
 * Version of git-lfs if installed
 */
version: string | null; 
/**
 * Whether LFS is initialized in the repository
 */
isInitialized: boolean; 
/**
 * Number of tracked patterns
 */
trackedPatternsCount: number; 
/**
 * Number of LFS files in the repository
 */
lfsFilesCount: number }
/**
 * A tracked LFS pattern
 */
export type LfsTrackedPattern = { 
/**
 * The pattern (e.g., "*.psd", "assets/*.png")
 */
pattern: string; 
/**
 * Source file where the pattern is defined (usually .gitattributes)
 */
sourceFile: string }
export type LogOptions = { limit: number | null; skip: number | null; fromRef: string | null; branchFilter?: BranchFilterType; includeRemotes?: boolean; sortOrder?: SortOrder }
/**
 * Menu item IDs for custom actions
 */
export type MenuAction = "NewWindow" | "OpenRepository" | "CloseRepository" | "Settings" | "Refresh" | "ToggleSidebar" | "Fetch" | "Pull" | "Push" | "StageAll" | "UnstageAll" | "Commit" | "NewBranch" | "NewTag" | "Stash" | "PopStash"
/**
 * Menu action triggered
 */
export type MenuActionEvent = { actionId: string }
/**
 * Merge method for pull requests
 */
export type MergeMethod = "Merge" | "Squash" | "Rebase"
/**
 * Options for merge operations
 */
export type MergeOptions = { 
/**
 * The branch to merge into the current branch
 */
branch: string; 
/**
 * Custom commit message (optional)
 */
message: string | null; 
/**
 * If true, always create a merge commit (no fast-forward)
 */
noFf: boolean; 
/**
 * If true, squash all commits into a single commit
 */
squash: boolean; 
/**
 * If true, only fast-forward (fail if not possible)
 */
ffOnly: boolean; 
/**
 * If true, don't create a commit (stage changes only)
 */
noCommit: boolean }
/**
 * Options for merging a pull request
 */
export type MergePrOptions = { mergeMethod: MergeMethod; commitTitle: string | null; commitMessage: string | null }
/**
 * Result of a merge operation
 */
export type MergeResult = { 
/**
 * Whether the merge was successful
 */
success: boolean; 
/**
 * Type of merge that occurred
 */
mergeType: MergeType; 
/**
 * New commit OID if a merge commit was created
 */
commitOid: string | null; 
/**
 * List of conflicted files if merge has conflicts
 */
conflicts: ConflictedFile[]; 
/**
 * Informational message
 */
message: string }
/**
 * Type of merge that occurred
 */
export type MergeType = 
/**
 * Already up to date
 */
"UpToDate" | 
/**
 * Fast-forward merge
 */
"FastForward" | 
/**
 * Normal merge (with merge commit)
 */
"Normal" | 
/**
 * Merge resulted in conflicts
 */
"Conflicted"
/**
 * Notification from integration provider
 */
export type Notification = { provider: ProviderType; id: string; reason: NotificationReason; unread: boolean; subjectTitle: string; subjectType: NotificationSubjectType; subjectUrl: string | null; repository: string; updatedAt: string; url: string }
/**
 * Notification reason
 */
export type NotificationReason = "Assigned" | "Author" | "Comment" | "Invitation" | "Manual" | "Mention" | "ReviewRequested" | "SecurityAlert" | "StateChange" | "Subscribed" | "TeamMention" | "CiActivity"
/**
 * Notification subject type
 */
export type NotificationSubjectType = "Issue" | "PullRequest" | "Release" | "Discussion" | "Commit" | "RepositoryVulnerabilityAlert" | "CheckSuite"
/**
 * Paginated notifications response
 */
export type NotificationsPage = { items: Notification[]; hasMore: boolean }
/**
 * OAuth callback received from deep link
 */
export type OAuthCallbackEvent = { provider: ProviderType; code: string; state: string | null }
/**
 * Operation currently in progress
 */
export type OperationState = 
/**
 * No operation in progress
 */
"None" | 
/**
 * Merge in progress
 */
{ Merging: { 
/**
 * Branch being merged
 */
branch: string | null } } | 
/**
 * Rebase in progress
 */
{ Rebasing: { 
/**
 * Branch being rebased onto
 */
onto: string | null; 
/**
 * Current step
 */
current: number | null; 
/**
 * Total steps
 */
total: number | null } } | 
/**
 * Cherry-pick in progress
 */
{ CherryPicking: { 
/**
 * Commit being cherry-picked
 */
commit: string | null } } | 
/**
 * Revert in progress
 */
{ Reverting: { 
/**
 * Commit being reverted
 */
commit: string | null } } | 
/**
 * Bisect in progress
 */
{ Bisecting: { 
/**
 * Current commit being tested
 */
current_commit: string | null; 
/**
 * Approximate steps remaining
 */
steps_remaining: number | null } }
/**
 * Result of a patch operation
 */
export type PatchResult = { 
/**
 * Message describing the result of the operation
 */
message: string; 
/**
 * Paths to created or applied patch files
 */
patches: string[] }
/**
 * Pull request state
 */
export type PrState = "Open" | "Closed" | "Merged" | "All"
export type ProgressStage = "Connecting" | "Counting" | "Compressing" | "Receiving" | "Resolving" | "Writing" | "Complete" | "Failed" | "Cancelled"
/**
 * Supported integration providers
 */
export type ProviderType = "GitHub" | "GitLab" | "Bitbucket" | "Gitea"
/**
 * Options for pull operations
 */
export type PullOptions = { 
/**
 * Rebase instead of merge
 */
rebase: boolean; 
/**
 * Fast-forward only
 */
ffOnly: boolean }
/**
 * Pull request summary for list views
 */
export type PullRequest = { provider: ProviderType; number: number; title: string; state: PrState; author: IntegrationUser; sourceBranch: string; targetBranch: string; draft: boolean; createdAt: string; updatedAt: string; url: string }
/**
 * Detailed pull request information
 */
export type PullRequestDetail = ({ provider: ProviderType; number: number; title: string; state: PrState; author: IntegrationUser; sourceBranch: string; targetBranch: string; draft: boolean; createdAt: string; updatedAt: string; url: string }) & { body: string | null; additions: number; deletions: number; changedFiles: number; commitsCount: number; commentsCount: number; mergeable: boolean | null; labels: IntegrationLabel[]; assignees: IntegrationUser[]; reviewers: IntegrationUser[] }
/**
 * Paginated pull requests response
 */
export type PullRequestsPage = { items: PullRequest[]; hasMore: boolean }
/**
 * Options for push operations
 */
export type PushOptions = { 
/**
 * Force push
 */
force: boolean; 
/**
 * Set upstream tracking
 */
setUpstream: boolean; 
/**
 * Push tags
 */
tags: boolean }
/**
 * Result of a push operation
 */
export type PushResult = { remote: string; pushedRefs: PushedRef[] }
export type PushStatus = "Ok" | "Rejected" | "UpToDate" | "RemoteRejected"
/**
 * A pushed reference result
 */
export type PushedRef = { refName: string; status: PushStatus; message: string | null }
/**
 * Action for each commit in interactive rebase
 */
export type RebaseAction = "Pick" | "Reword" | "Edit" | "Squash" | "Fixup" | "Drop"
/**
 * Options for rebase operations
 */
export type RebaseOptions = { 
/**
 * The branch/commit to rebase onto
 */
onto: string; 
/**
 * If true, use interactive rebase (requires editor)
 */
interactive: boolean; 
/**
 * If true, preserve merge commits
 */
preserveMerges: boolean; 
/**
 * Autosquash fixup commits
 */
autosquash: boolean }
/**
 * Preview data for a rebase operation
 */
export type RebasePreview = { 
/**
 * Commits that will be rebased (from branch tip to merge-base)
 */
commitsToRebase: Commit[]; 
/**
 * The merge-base commit (fork point)
 */
mergeBase: Commit; 
/**
 * Target branch/commit info
 */
target: RebaseTarget; 
/**
 * Number of commits on target since merge-base
 */
targetCommitsAhead: number }
/**
 * Result of a rebase operation
 */
export type RebaseResult = { 
/**
 * Whether the rebase was successful
 */
success: boolean; 
/**
 * Number of commits rebased
 */
commitsRebased: number; 
/**
 * Current commit being rebased (if in progress)
 */
currentCommit: string | null; 
/**
 * Total commits to rebase
 */
totalCommits: number | null; 
/**
 * Conflicted files if rebase has conflicts
 */
conflicts: ConflictedFile[]; 
/**
 * Informational message
 */
message: string }
/**
 * Target information for rebase preview
 */
export type RebaseTarget = { 
/**
 * Branch name or commit short_oid
 */
name: string; 
/**
 * Full commit OID
 */
oid: string; 
/**
 * Short commit OID
 */
shortOid: string; 
/**
 * Commit summary
 */
summary: string }
export type RecentRepository = { path: string; name: string; lastOpened: string }
/**
 * A ref (branch, tag) changed
 */
export type RefChangedEvent = { refName: string }
/**
 * Type of reference
 */
export type RefType = "LocalBranch" | "RemoteBranch" | "Tag"
export type RefUpdateStatus = "FastForward" | "Forced" | "New" | "Deleted" | "Rejected" | "UpToDate"
/**
 * Parsed reflog action type for categorization and UI display
 */
export type ReflogAction = "Commit" | "CommitAmend" | "CommitInitial" | "Checkout" | "Merge" | "Rebase" | "Reset" | "CherryPick" | "Revert" | "Pull" | "Clone" | "Branch" | "Stash" | { Other: string }
/**
 * Represents a single reflog entry
 */
export type ReflogEntry = { 
/**
 * Index of the entry (0 = most recent)
 */
index: number; 
/**
 * Reference notation (e.g., "HEAD@{0}", "refs/heads/main@{1}")
 */
reflogRef: string; 
/**
 * The commit OID after this action
 */
newOid: string; 
/**
 * Short form of new_oid
 */
shortNewOid: string; 
/**
 * The commit OID before this action (can be all zeros for initial commit)
 */
oldOid: string; 
/**
 * Short form of old_oid
 */
shortOldOid: string; 
/**
 * Action type parsed from message
 */
action: ReflogAction; 
/**
 * Full reflog message
 */
message: string; 
/**
 * Author/committer name
 */
committerName: string; 
/**
 * Author/committer email
 */
committerEmail: string; 
/**
 * Timestamp of the action
 */
timestamp: string }
/**
 * Options for fetching reflog entries
 */
export type ReflogOptions = { 
/**
 * Reference to get reflog for (default: "HEAD")
 */
refname: string | null; 
/**
 * Maximum number of entries to return
 */
limit: number | null; 
/**
 * Number of entries to skip (for pagination)
 */
skip: number | null }
/**
 * Represents a Git remote
 */
export type Remote = { name: string; url: string | null; pushUrl: string | null; fetchRefspecs: string[]; pushRefspecs: string[] }
/**
 * Remote fetch completed with new commits
 */
export type RemoteFetchedEvent = { path: string; newCommits: number }
/**
 * Options for removing a worktree
 */
export type RemoveWorktreeOptions = { 
/**
 * Path of the worktree to remove
 */
path: string; 
/**
 * Force removal even with uncommitted changes
 */
force: boolean }
export type Repository = { id: string; name: string; path: string; isBare: boolean; isUnborn: boolean; currentBranch: string | null; state: RepositoryState }
/**
 * Repository has changes (for inactive repo tab badges)
 */
export type RepositoryDirtyEvent = { path: string }
/**
 * Repository-specific settings
 */
export type RepositorySettings = { 
/**
 * Repository user.name (from .git/config)
 */
userName: string | null; 
/**
 * Repository user.email (from .git/config)
 */
userEmail: string | null; 
/**
 * Global user.name (for placeholder display)
 */
globalUserName: string | null; 
/**
 * Global user.email (for placeholder display)
 */
globalUserEmail: string | null; 
/**
 * List of remotes
 */
remotes: Remote[] }
export type RepositoryState = "Clean" | "Merging" | "Rebasing" | "RebasingInteractive" | "CherryPicking" | "Reverting" | "Bisecting" | "ApplyMailbox" | "ApplyMailboxOrRebase"
export type RepositoryStatus = { staged: FileStatus[]; unstaged: FileStatus[]; untracked: FileStatus[]; conflicted: FileStatus[] }
/**
 * Reset mode for reset operations
 */
export type ResetMode = 
/**
 * Keep changes staged
 */
"Soft" | 
/**
 * Keep changes unstaged
 */
"Mixed" | 
/**
 * Discard all changes
 */
"Hard"
/**
 * Options for reset operations
 */
export type ResetOptions = { 
/**
 * Target commit/ref to reset to
 */
target: string; 
/**
 * Reset mode (soft, mixed, hard)
 */
mode: ResetMode }
/**
 * Options for revert operations
 */
export type RevertOptions = { 
/**
 * Commit(s) to revert
 */
commits: string[]; 
/**
 * If true, don't create commits (stage changes only)
 */
noCommit: boolean }
/**
 * Result of a revert operation
 */
export type RevertResult = { 
/**
 * Whether the revert was successful
 */
success: boolean; 
/**
 * New commit OIDs created
 */
commitOids: string[]; 
/**
 * Conflicted files if revert has conflicts
 */
conflicts: ConflictedFile[]; 
/**
 * Informational message
 */
message: string }
/**
 * Search options for commit search
 */
export type SearchOptions = { 
/**
 * Search query
 */
query: string; 
/**
 * Search in message
 */
searchMessage: boolean; 
/**
 * Search in author name/email
 */
searchAuthor: boolean; 
/**
 * Search in commit hash
 */
searchHash: boolean; 
/**
 * Maximum results
 */
limit: number | null }
/**
 * Search result
 */
export type SearchResult = { commits: Commit[]; totalMatches: number }
export type Signature = { name: string; email: string; timestamp: string }
/**
 * Configuration for commit signing (how to sign, not whether to sign)
 */
export type SigningConfig = { 
/**
 * Signing format (GPG or SSH)
 */
format: SigningFormat; 
/**
 * Signing key (GPG key ID or SSH key path)
 */
signingKey: string | null; 
/**
 * Custom GPG program path
 */
gpgProgram: string | null; 
/**
 * Custom SSH signing program path
 */
sshProgram: string | null }
/**
 * Signing format - GPG (OpenPGP) or SSH
 */
export type SigningFormat = "Gpg" | "Ssh"
/**
 * Result of testing signing configuration
 */
export type SigningTestResult = { 
/**
 * Whether the test was successful
 */
success: boolean; 
/**
 * Error message if failed
 */
error: string | null; 
/**
 * The signing program that was used
 */
programUsed: string | null }
export type SortOrder = "DateOrder" | "AncestorOrder"
/**
 * Represents an SSH key available for signing
 */
export type SshKey = { 
/**
 * Path to the private key file
 */
path: string; 
/**
 * Key type (ed25519, rsa, etc.)
 */
keyType: string; 
/**
 * Comment from the public key (usually email)
 */
comment: string | null }
/**
 * Options for applying/popping a stash
 */
export type StashApplyOptions = { 
/**
 * Stash index to apply (default: 0)
 */
index: number | null; 
/**
 * Reinstate the staged changes
 */
reinstateIndex: boolean }
/**
 * Represents a stash entry
 */
export type StashEntry = { 
/**
 * Index of the stash (0 = most recent)
 */
index: number; 
/**
 * Full stash reference (e.g., "stash@{0}")
 */
stashRef: string; 
/**
 * Stash message
 */
message: string; 
/**
 * Commit OID of the stash commit
 */
commitOid: string; 
/**
 * Short commit OID
 */
shortOid: string; 
/**
 * Branch the stash was created on
 */
branch: string | null; 
/**
 * Author of the stash
 */
author: string; 
/**
 * Timestamp when the stash was created
 */
timestamp: string }
/**
 * Result of a stash operation
 */
export type StashResult = { 
/**
 * Message describing the result of the operation
 */
message: string; 
/**
 * Number of files stashed/restored
 */
filesAffected: number; 
/**
 * Conflicts if any when applying
 */
conflicts: string[] }
/**
 * Options for creating a stash
 */
export type StashSaveOptions = { 
/**
 * Message for the stash
 */
message: string | null; 
/**
 * Include untracked files
 */
includeUntracked: boolean; 
/**
 * Keep the staged changes in the index
 */
keepIndex: boolean; 
/**
 * Include ignored files
 */
includeIgnored: boolean }
export type StatusType = "Untracked" | "Added" | "Modified" | "Deleted" | "Renamed" | "Copied" | "TypeChanged" | "Ignored" | "Conflicted"
/**
 * Represents a Git submodule
 */
export type Submodule = { 
/**
 * Submodule name
 */
name: string; 
/**
 * Path within the parent repository
 */
path: string; 
/**
 * Remote URL
 */
url: string | null; 
/**
 * Current HEAD commit of the submodule
 */
headOid: string | null; 
/**
 * Short HEAD OID
 */
shortOid: string | null; 
/**
 * Expected commit from parent repo's index
 */
indexedOid: string | null; 
/**
 * Branch being tracked (if any)
 */
branch: string | null; 
/**
 * Status of the submodule
 */
status: SubmoduleStatus }
/**
 * Result of a submodule operation
 */
export type SubmoduleResult = { success: boolean; message: string; 
/**
 * Affected submodules
 */
submodules: string[] }
/**
 * Status of a submodule
 */
export type SubmoduleStatus = 
/**
 * Submodule is up to date
 */
"Current" | 
/**
 * Submodule has new commits
 */
"Modified" | 
/**
 * Submodule is not initialized
 */
"Uninitialized" | 
/**
 * Submodule is missing from disk
 */
"Missing" | 
/**
 * Submodule has merge conflicts
 */
"Conflict" | 
/**
 * Submodule workdir is dirty
 */
"Dirty" | 
/**
 * Unknown status
 */
"Unknown"
/**
 * Options for syncing submodules
 */
export type SyncSubmoduleOptions = { 
/**
 * Specific submodule paths to sync (empty = all)
 */
paths: string[]; 
/**
 * Sync recursively
 */
recursive: boolean }
/**
 * Represents a Git tag
 */
export type Tag = { 
/**
 * Tag name
 */
name: string; 
/**
 * Full ref name (e.g., "refs/tags/v1.0.0")
 */
fullName: string; 
/**
 * Target commit OID
 */
targetOid: string; 
/**
 * Short target OID
 */
shortOid: string; 
/**
 * Whether this is an annotated tag
 */
isAnnotated: boolean; 
/**
 * Tag message (for annotated tags)
 */
message: string | null; 
/**
 * Tagger information (for annotated tags)
 */
tagger: TagSignature | null; 
/**
 * Commit summary for the target
 */
targetSummary: string | null; 
/**
 * Timestamp of the target commit
 */
targetTime: string | null }
/**
 * Result of a tag operation
 */
export type TagResult = { success: boolean; message: string; tag: Tag | null }
/**
 * Signature for a tag tagger
 */
export type TagSignature = { name: string; email: string; timestamp: string }
export type Theme = "Light" | "Dark" | "System"
/**
 * Options for updating submodules
 */
export type UpdateSubmoduleOptions = { 
/**
 * Specific submodule paths to update (empty = all)
 */
paths: string[]; 
/**
 * Initialize uninitialized submodules
 */
init: boolean; 
/**
 * Update recursively
 */
recursive: boolean; 
/**
 * Force update (discard local changes)
 */
force: boolean; 
/**
 * Fetch new commits from remote
 */
remote: boolean; 
/**
 * Rebase instead of merge when updating
 */
rebase: boolean; 
/**
 * Merge instead of checkout
 */
merge: boolean }
/**
 * An updated reference from fetch/push
 */
export type UpdatedRef = { refName: string; oldOid: string | null; newOid: string | null; status: RefUpdateStatus }
/**
 * Watch error occurred
 */
export type WatchErrorEvent = { message: string }
/**
 * Represents a Git worktree
 */
export type Worktree = { 
/**
 * Absolute path to the worktree directory
 */
path: string; 
/**
 * Branch name (None if detached HEAD)
 */
branch: string | null; 
/**
 * Current HEAD commit OID
 */
headOid: string; 
/**
 * Short HEAD OID (7 characters)
 */
shortOid: string; 
/**
 * Whether this worktree is locked
 */
isLocked: boolean; 
/**
 * Lock reason (if locked)
 */
lockReason: string | null; 
/**
 * Whether this is the main worktree
 */
isMain: boolean; 
/**
 * Whether the worktree is prunable (directory missing)
 */
isPrunable: boolean }
/**
 * Result of a worktree operation
 */
export type WorktreeResult = { 
/**
 * Whether the operation succeeded
 */
success: boolean; 
/**
 * Message describing the result
 */
message: string; 
/**
 * Path of the affected worktree
 */
path: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
